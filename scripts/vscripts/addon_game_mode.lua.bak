-- This is the entry-point to your game mode and should be used primarily to precache models/particles/sounds/etc

require('stk_api')


thisunitlist = {
	{name = "basic_unit_melee_1", count = 3},
	{name = "basic_unit_melee_2", count = 0},
	{name = "basic_unit_melee_3", count = 0},
	{name = "basic_unit_melee_4", count = 0},
	{name = "basic_unit_melee_5", count = 0},
	{name = "basic_unit_melee_6", count = 0},
	{name = "basic_unit_melee_7", count = 0},
	{name = "basic_unit_range_1", count = 1},
	{name = "basic_unit_range_2", count = 0},
	{name = "basic_unit_range_3", count = 0},
	{name = "basic_unit_range_4", count = 0},
	{name = "basic_unit_range_5", count = 0},
	{name = "basic_unit_range_6", count = 0},
	{name = "basic_unit_range_7", count = 0},
	{name = "basic_unit_buffer_1", count = 0},
	{name = "basic_unit_buffer_2", count = 0},
	{name = "basic_unit_buffer_3", count = 0},
	{name = "basic_unit_buffer_4", count = 0},
	{name = "basic_unit_buffer_5", count = 0},
	{name = "basic_unit_buffer_6", count = 0},
	{name = "basic_unit_buffer_7", count = 0},
	{name = "basic_unit_special_1", count = 0},
	{name = "basic_unit_special_2", count = 0},
	{name = "basic_unit_special_3", count = 0},
	{name = "basic_unit_special_4", count = 0},
	{name = "basic_unit_special_5", count = 0},
	{name = "basic_unit_special_6", count = 0},
	{name = "basic_unit_special_7", count = 0},
	{name = "boss_unit_doom", count = 0},
	{name = "boss_unit_legion_commander", count = 0},
	{name = "boss_unit_demonic_spirit", count = 0},
}




function spawnOneCreep(unit, start_point, target_point, team)	
		local r_unit = CreateUnitByName( unit, start_point + RandomVector( RandomFloat( 0, 200 ) ), true, nil, nil, team )
		r_unit:SetInitialGoalEntity( target_point )	
end

function GameMode:UnitPanelDebug(data)
	if PlayerResource:GetConnectionState(data.PlayerID) == DOTA_CONNECTION_STATE_CONNECTED and PlayerResource:GetPlayer(data.PlayerID) ~= nil and PlayerResource:IsValidPlayer(data.PlayerID) then
		CustomGameEventManager:Send_ServerToPlayer( PlayerResource:GetPlayer(data.PlayerID), "load_allunits", GameRules.unitdata )
		CustomGameEventManager:Send_ServerToPlayer( PlayerResource:GetPlayer(data.PlayerID), "load_allupgrades", CDOTA_PlayerResource:GetUpgradelist(data.PlayerID) )
		Msg("Unitpanel debug has called;")
	end
end

function OnPlayerPanoramaReady()
	
end

function GameMode:OnAllPlayersLoaded()
	CustomGameEventManager:RegisterListener( "player_panorama_ready", Dynamic_Wrap(GameMode, "OnPlayerPanoramaReady") )	
	
	CustomGameEventManager:RegisterListener( "buy_unit", Dynamic_Wrap(GameMode, "OnBuyUnit") )
	CustomGameEventManager:RegisterListener( "buy_upgrade", Dynamic_Wrap(GameMode, "OnBuyUpgrade") )
	CustomGameEventManager:RegisterListener( "sell_unit", Dynamic_Wrap(GameMode, "OnSellUnit") )
	
	CustomGameEventManager:RegisterListener( "unitpanel_debug", Dynamic_Wrap(GameMode, "UnitPanelDebug") )
	
	keyvalue = LoadKeyValues("scripts/npc/npc_units_custom.txt")
	Msg("Keyvalues loaded;")		
	for a, unit in pairs(thisunitlist) do 
		GameRules.unitdata[unit.name] = {UnitType = keyvalue[unit.name].UnitType, unitindex = keyvalue[unit.name].UnitIndex, AItype = keyvalue[unit.name].AItype, ancient = keyvalue[unit.name].AncientUnit, unitclass = keyvalue[unit.name].UnitClass, cost = keyvalue[unit.name].UnitCost, income = keyvalue[unit.name].UnitIncome, food = keyvalue[unit.name].NeedFood, health = keyvalue[unit.name].StatusHealth, page = keyvalue[unit.name].UnitPage, mindamage = keyvalue[unit.name].AttackDamageMin, maxdamage = keyvalue[unit.name].AttackDamageMax, attackrange = keyvalue[unit.name].AttackRange, armor = keyvalue[unit.name].ArmorPhysical, ability1 = keyvalue[unit.name].Ability1, ability2 = keyvalue[unit.name].Ability2, ability3 = keyvalue[unit.name].Ability3, ability4 = keyvalue[unit.name].Ability4, ability5 = keyvalue[unit.name].Ability5}
	end
	if GetMapName() == "4x4_paladins" then
		local teamlist = {DOTA_TEAM_GOODGUYS, DOTA_TEAM_BADGUYS}
		for _, team in ipairs(teamlist) do
			local pos_vector = Entities:FindByName( nil, "ve_keeper_".. team):GetAbsOrigin()	
			local crunit = CreateUnitByName( "npc_dota_ve_keeper", pos_vector, true, nil, nil, team)
		end
	end
	
	Msg("GameRules.unitdata loaded;")
	Timers:CreateTimer(0.1, function()
			if CURRENT_STATE_TIME == 0 then
				CURRENT_STATE_TIME = STATECHANGE_TIME_CONSTANT
				GAME_STATE_NUMBER = GAME_STATE_NUMBER + 1
				for playerID = 0, DOTA_MAX_TEAM_PLAYERS-1 do
					if PlayerResource:GetPlayer(playerID) ~= nil and PlayerResource:IsValidPlayer(playerID) and PlayerResource:HasSelectedHero( playerID ) then
						CDOTA_PlayerResource:SetMaxFood(playerID, CDOTA_PlayerResource:GetMaxFood(playerID) + BONUS_FOOD*GAME_STATE_NUMBER)
						CustomGameEventManager:Send_ServerToPlayer(PlayerResource:GetPlayer(playerID), "player_newfood", {food = CDOTA_PlayerResource:GetFood(playerID), maxfood = CDOTA_PlayerResource:GetMaxFood(playerID)} )
					end
				end				
			end
			CURRENT_STATE_TIME = CURRENT_STATE_TIME - 1
			for playerID = 0, DOTA_MAX_TEAM_PLAYERS-1 do
				if game_IsValidPlayer(playerID) then
					CustomGameEventManager:Send_ServerToPlayer(PlayerResource:GetPlayer(playerID), "timer_going", {round_time = ROUND_TIME, income_time = INCOME_TIME, game_state_number = GAME_STATE_NUMBER, state_time = CURRENT_STATE_TIME, game_constant = STATECHANGE_TIME_CONSTANT} )
				end 
			end
			if INCOME_TIME > 0 then INCOME_TIME = INCOME_TIME - 1 end
			if ROUND_TIME > 0 then ROUND_TIME = ROUND_TIME - 1 end
		return 1.0
	end)
end

function GameMode:OrderFilter( filterTable )
  local units = filterTable["units"]
  local orderType = filterTable["order_type"]
  local target = EntIndexToHScript(filterTable["entindex_target"])

  if orderType == DOTA_UNIT_ORDER_ATTACK_TARGET then
    for _,unitIndex in pairs(units) do
      local attacker = EntIndexToHScript(unitIndex)
      if target and attacker then
        if target:GetTeamNumber() == attacker:GetTeamNumber() then
          return false
        end
      end
    end
  end
  return true
end

function GameMode:OnGameRulesStateChange(keys)
  local newState = GameRules:State_Get()
  if newState == DOTA_GAMERULES_STATE_STRATEGY_TIME then
	for playerID = 0, DOTA_MAX_TEAM_PLAYERS-1 do
		--if PlayerResource:GetPlayer(playerID) ~= nil and PlayerResource:IsValidPlayer(playerID) then
		if PlayerResource:GetConnectionState(playerID) == DOTA_CONNECTION_STATE_CONNECTED then
			--print(PlayerResource:GetSelectedHeroID(playerID))
			if PlayerResource:GetSelectedHeroID(playerID) == -1 then
				PlayerResource:GetPlayer(playerID):MakeRandomHeroSelection()
			end
		end
	end
  end
  if newState == DOTA_GAMERULES_STATE_PRE_GAME then			
	ROUND_TIME = 30.0
	INCOME_TIME = 30.0
  end
end
 
function GameMode:OnHeroInGame(hero)
	local ownerid = hero:GetPlayerOwnerID()		
	Msg("load_allunits event started;")
	if GetMapName() ~= "4x4_paladins" then
		local pos_vector = Entities:FindByName( nil, "ve_keeper_"..hero:GetTeam() ):GetAbsOrigin()	
		local crunit = CreateUnitByName( "npc_dota_ve_keeper", pos_vector, true, hero, hero, hero:GetTeam())
		crunit:SetOwner(hero)
		crunit:SetControllableByPlayer(hero:GetPlayerOwnerID(), true)		
	end

	
	if PlayerResource:GetConnectionState(ownerid) == DOTA_CONNECTION_STATE_CONNECTED and PlayerResource:GetPlayer(ownerid) ~= nil and PlayerResource:IsValidPlayer(ownerid) then
		local curunitlist = CDOTA_PlayerResource:GetUnitlist(ownerid)
		CustomGameEventManager:Send_ServerToPlayer(PlayerResource:GetPlayer(ownerid), "load_allconfigs", {incomeconst = INCOME_COUNT} )
		CustomGameEventManager:Send_ServerToPlayer(PlayerResource:GetPlayer(ownerid), "load_allunits", GameRules.unitdata )
		CustomGameEventManager:Send_ServerToPlayer(PlayerResource:GetPlayer(ownerid), "load_allupgrades", CDOTA_PlayerResource:GetUpgradelist(ownerid) )
		--DeepPrintTable(curunitlist)
		CustomGameEventManager:Send_ServerToPlayer( PlayerResource:GetPlayer(ownerid), "load_playerunits", curunitlist )
	end
	
	if GetMapName() == "paladins_arena" then
		AddFOWViewer(hero:GetTeam(), Entities:FindByName( nil, "point_fow"):GetAbsOrigin(), 1300.0, 9999.0, false) 		
		if hero:GetTeam() == 2 then
			if PlayerResource:GetPlayerCountForTeam(6) == 0 then
				parseNewPos(0, hero:GetTeam())
			end
		elseif hero:GetTeam() == 3 then
			if PlayerResource:GetPlayerCountForTeam(7) == 0 then
				parseNewPos(0, hero:GetTeam())
			end
		elseif hero:GetTeam() == 6 then
			if PlayerResource:GetPlayerCountForTeam(2) == 0 then
				parseNewPos(0, hero:GetTeam())
			end
		elseif hero:GetTeam() == 7 then
			if PlayerResource:GetPlayerCountForTeam(3) == 0 then
				parseNewPos(0, hero:GetTeam())
			end
		end
	end
end

function deepcopy(object)
	local lookup_table = {}
	local function _copy(object)	
		if type(object) ~= "table" then
			return object
		elseif lookup_table[object] then
			return lookup_table[object]
		end
		
		local new_table = {}	
		lookup_table[object] = new_table
		
		for index, value in pairs(object) do
			new_table[_copy(index)] = _copy(value)
		end
		
		return setmetatable(new_table, _copy(getmetatable(object)))
	end
	return _copy(object)
end

function GameMode:OnBuyUnit(event)
	
	local hero = PlayerResource:GetSelectedHeroEntity(event.PlayerID)
	if event.count ~= nil then
		local myfood = CDOTA_PlayerResource:GetFood(event.PlayerID)
		if hero:GetGold() >= GameRules.unitdata[event.name].cost and myfood + GameRules.unitdata[event.name].food <= CDOTA_PlayerResource:GetMaxFood(event.PlayerID)then
			CDOTA_PlayerResource:SetIncome(event.PlayerID, CDOTA_PlayerResource:GetIncome(event.PlayerID) + GameRules.unitdata[event.name].income)
			CDOTA_PlayerResource:SetFood(event.PlayerID, myfood + GameRules.unitdata[event.name].food)
			if event.count == 0 and hero:GetRespawnsDisabled() == false then
				local team = hero:GetTeam()
				if GetMapName() == "paladins_arena" then
					spawnCreep(event.name, 1, Entities:FindByName( nil, "spawn_" .. team .. "center"):GetAbsOrigin(), Entities:FindByName( nil, "target_point_" .. team .. "center1"), team, hero)
					spawnCreep(event.name, 1, Entities:FindByName( nil, "spawn_" .. team .. "left"):GetAbsOrigin(), Entities:FindByName( nil, "target_point_" .. team .. "left1"), team, hero)
					spawnCreep(event.name, 1, Entities:FindByName( nil, "spawn_" .. team .. "right"):GetAbsOrigin(), Entities:FindByName( nil, "target_point_" .. team .. "right1"), team, hero)				
				elseif GetMapName() == "4x4_paladins" then	
					local playerCount = PlayerResource:GetPlayerCountForTeam(team)
					if playerCount ~= 0 then
						for i = 1, playerCount do
							if PlayerResource:GetNthPlayerIDOnTeam(team, i) == event.PlayerID then
								local t_point
								if i == 1 or i == 2 then t_point = "_1-3"
								elseif i == 3 or i == 4 then t_point = "_2-4" end
								spawnCreep(event.name, 1, Entities:FindByName( nil, "spawn_" .. team .. "_" .. i):GetAbsOrigin(), Entities:FindByName( nil, "point_" .. team .. "_start" .. t_point), team, hero)		
							end
						end
					end
				else
					spawnCreep(event.name, 1, Entities:FindByName( nil, "spawn_" .. team):GetAbsOrigin(), Entities:FindByName( nil, "point_" .. team), team, hero)
				end
			else
				CDOTA_PlayerResource:SetUnitCount(event.PlayerID, event.name, event.count)
			end
			local curunitlist = CDOTA_PlayerResource:GetUnitlist(hero:GetPlayerOwnerID())
			--DeepPrintTable(curunitlist)
			PlayerResource:SpendGold(event.PlayerID, GameRules.unitdata[event.name].cost, 1)
			LoadPlayerUnits(event.PlayerID)		
			CustomGameEventManager:Send_ServerToPlayer( PlayerResource:GetPlayer(event.PlayerID), "unitbuy_success", {income = CDOTA_PlayerResource:GetIncome(event.PlayerID), food = CDOTA_PlayerResource:GetFood(event.PlayerID), maxfood = CDOTA_PlayerResource:GetMaxFood(event.PlayerID)} )
		end
	end
end

function GameMode:OnBuyUpgrade(event)
	
	local hero = PlayerResource:GetSelectedHeroEntity(event.PlayerID)
	local curunitlist = CDOTA_PlayerResource:GetUpgradelist(event.PlayerID)
	
	if hero:GetGold() >= curunitlist[event.name].cost then
		curunitlist[event.name].level = curunitlist[event.name].level + 1
		local cost = curunitlist[event.name].cost + UPGRADE_COST_CONST*curunitlist[event.name].level
		PlayerResource:SpendGold(event.PlayerID, curunitlist[event.name].cost, 1)
		curunitlist[event.name].cost = cost;
		CDOTA_PlayerResource:SetUpgradelist(hero:GetPlayerOwnerID(), curunitlist)		
		CustomGameEventManager:Send_ServerToPlayer( PlayerResource:GetPlayer(event.PlayerID), "upgradebuy_success", curunitlist )
	end
end

function GameMode:OnSellUnit(event)
	
	local hero = PlayerResource:GetSelectedHeroEntity(event.PlayerID)
	local unitcount = 0;
	local istrue = true
	local curunitlist = CDOTA_PlayerResource:GetUnitlist(event.PlayerID)
	if event.count ~= nil then
		for a, unit in pairs(curunitlist) do
			if unit.name == event.name then
				if unit.count == 0 then
					istrue = false
					break
				end
			end
			if unit.count > 0 then unitcount = unitcount + unit.count end
		end
		if istrue == true then
			if unitcount > 4 then
				CDOTA_PlayerResource:SetIncome(event.PlayerID, CDOTA_PlayerResource:GetIncome(event.PlayerID) - GameRules.unitdata[event.name].income)
				CDOTA_PlayerResource:SetFood(event.PlayerID, CDOTA_PlayerResource:GetFood(event.PlayerID) - GameRules.unitdata[event.name].food)
				PlayerResource:ModifyGold(hero:GetPlayerOwnerID(), GameRules.unitdata[event.name].cost, false, 1)
				CDOTA_PlayerResource:SetUnitCount(event.PlayerID, event.name, event.count*-1)
				LoadPlayerUnits(event.PlayerID)
				CustomGameEventManager:Send_ServerToPlayer( PlayerResource:GetPlayer(event.PlayerID), "unitbuy_success", {income = CDOTA_PlayerResource:GetIncome(event.PlayerID), food = CDOTA_PlayerResource:GetFood(event.PlayerID), maxfood = CDOTA_PlayerResource:GetMaxFood(event.PlayerID)} )
			end
		end
	end

end

function GameMode:OnGameInProgress()

	Timers:CreateTimer(0.1, function()
		local allHeroes = HeroList:GetAllHeroes()
		for _,hero in pairs(allHeroes) do
			if not hero:IsIllusion() then
				local ownerid = hero:GetPlayerOwnerID()
				if game_IsValidPlayer(ownerid) then
					local curunitlist = CDOTA_PlayerResource:GetUnitlist(ownerid)
					local team = hero:GetTeam()
					for key,unit in pairs(curunitlist) do
						if unit.count > 0 then
							if GetMapName() == "paladins_arena" then
								spawnCreep(unit.name, unit.count, Entities:FindByName( nil, "spawn_" .. team .. "center"):GetAbsOrigin(), Entities:FindByName( nil, "target_point_" .. team .. "center1"), team, hero)
								spawnCreep(unit.name, unit.count, Entities:FindByName( nil, "spawn_" .. team .. "left"):GetAbsOrigin(), Entities:FindByName( nil, "target_point_" .. team .. "left1"), team, hero)
								spawnCreep(unit.name, unit.count, Entities:FindByName( nil, "spawn_" .. team .. "right"):GetAbsOrigin(), Entities:FindByName( nil, "target_point_" .. team .. "right1"), team, hero)
							elseif GetMapName() == "4x4_paladins" then
								local playerCount = PlayerResource:GetPlayerCountForTeam(team)
								if playerCount ~= 0 then
									for i = 1, playerCount do
										if PlayerResource:GetNthPlayerIDOnTeam(team, i) == ownerid then
											local t_point
											if i == 1 or i == 2 then t_point = "_1-3"
											elseif i == 3 or i == 4 then t_point = "_2-4" end
											spawnCreep(unit.name, unit.count, Entities:FindByName( nil, "spawn_" .. team .. "_" .. i):GetAbsOrigin(), Entities:FindByName( nil, "point_" .. team .. "_start" .. t_point), team, hero)
										end
									end
								end
							else
								spawnCreep(unit.name, unit.count, Entities:FindByName( nil, "spawn_" .. team):GetAbsOrigin(), Entities:FindByName( nil, "point_" .. team), team, hero)
							end
							
							--Msg(hero:GetTeam() .. " - Spawned Creep - " .. unit.name .. " - Count: ".. unit.count .. "\n");				
						end
					end
				end
			end
		end
		ROUND_TIME = ROUND_DELAY
		return ROUND_DELAY
	end)
	Timers:CreateTimer(0.1, function()
		local allHeroes = HeroList:GetAllHeroes()
		for _,hero in pairs(allHeroes) do
			if not hero:IsIllusion() then
			local ownerid = hero:GetPlayerOwnerID()
				if game_IsValidPlayer(ownerid) then
					local team = hero:GetTeam()
					local myincome = CDOTA_PlayerResource:GetIncome(ownerid)
					PlayerResource:ModifyGold(ownerid, INCOME_COUNT*myincome, false, 1)
				end
			end
		end 		
		INCOME_TIME = INCOME_DELAY
		return INCOME_DELAY
	end)
end

function Precache( context )
	PrecacheEveryThingFromKV(context)
	PrecacheUnitByNameSync("npc_dota_hero_dragon_knight", context)
	PrecacheUnitByNameSync("npc_dota_hero_sniper", context)
	PrecacheUnitByNameSync("npc_dota_hero_vengefulspirit", context)
	PrecacheUnitByNameSync("npc_dota_hero_treant", context)
	PrecacheUnitByNameSync("npc_dota_hero_omniknight", context)
	PrecacheUnitByNameSync("npc_dota_hero_doom_bringer", context)
	PrecacheUnitByNameSync("npc_dota_Hero_crystal_maiden", context)
	PrecacheUnitByNameSync("npc_dota_hero_legion_commander", context)
	PrecacheUnitByNameSync("npc_dota_hero_zuus", context)
	PrecacheUnitByNameSync("npc_dota_hero_chen", context)
	PrecacheUnitByNameSync("npc_dota_hero_silencer", context)
end

function Activate()
  GameRules.GameMode = GameMode()
  GameRules.GameMode:_InitGameMode()
  
end

function GameMode:InitGameMode()
	--ListenToGameEvent("player_connect_full", Dynamic_Wrap(CDOTA_PlayerResource, "util_onPlayerConnect"), self)
	ListenToGameEvent("player_reconnected", Dynamic_Wrap(CDOTA_PlayerResource, 'util_onPlayerReConnect'), self)
	GameRules:GetGameModeEntity():SetExecuteOrderFilter(Dynamic_Wrap(GameMode, "OrderFilter"), self)
	GameRules:GetGameModeEntity():SetDamageFilter( Dynamic_Wrap( GameMode, "util_OnTakeDamage" ), self )
	--GameRules:GetGameModeEntity():SetModifyGoldFilter(Dynamic_Wrap(GameMode,"FilterModifyGold"),self)
	
	LinkLuaModifier( "modifier_aether_staff_lua", "items/aether_staff_modifier.lua",LUA_MODIFIER_MOTION_NONE )
	
    print( "Loading AI Testing Game Mode." )
    -- SEEDING RNG IS VERY IMPORTANT
    math.randomseed(Time())

    -- Set up a table to hold all the units we want to spawn
    GameMode.UnitThinkerList = {}

    -- Set the unit thinker function
	Timers:CreateTimer(0.1, function()
		OnUnitThink()
		return 0.1
	end)
end

function OnUnitThink()
    if GameRules:State_Get() == DOTA_GAMERULES_STATE_GAME_IN_PROGRESS then

        local deadUnitCount = 0
        for ind, unit in pairs(GameMode.UnitThinkerList) do
            if unit:IsNull() or not unit:IsAlive() then
                table.remove(GameMode.UnitThinkerList, ind - deadUnitCount)
                deadUnitCount = deadUnitCount + 1
            elseif GameRules:GetGameTime() > unit.NextOrderTime then
				local curvar = 5
                if unit.ThinkerType == "wander" then

                    local x = math.random(unit.wanderBounds.XMin, unit.wanderBounds.XMax)
                    local y = math.random(unit.wanderBounds.YMin, unit.wanderBounds.YMax)
                    local z = GetGroundHeight(Vector(x, y, 128), nil)

                    print("wandering to x: " .. x .. " y: " .. y)

                    -- Issue the movement order to the unit
                    unit:MoveToPosition(Vector(x, y, z))

                elseif unit.ThinkerType == "target_caster" then
                    --print("casting heal ability " .. EntIndexToHScript(unit.CastAbilityIndex):GetName())
					local utarget
					local eability = EntIndexToHScript(unit.CastAbilityIndex)
					if eability:IsFullyCastable() then
						local tarunits = FindUnitsInRadius(unit:GetTeam(), unit:GetAbsOrigin(), nil, unit:GetAcquisitionRange(), DOTA_UNIT_TARGET_TEAM_ENEMY, DOTA_UNIT_TARGET_ALL, DOTA_UNIT_TARGET_FLAG_NONE, FIND_ANY_ORDER, false)
						--DeepPrintTable(tarCDOTA_PlayerResource:GetUnitlist)
						for kev, funit in pairs(tarunits) do
							if funit:IsAlive() then
								if not utarget then 
									utarget = funit
								elseif funit:GetHealthPercent() < utarget:GetHealthPercent() then
									utarget = funit
								end
							end
						end
						if utarget and utarget:IsAlive() and unit:GetMana() >= eability:GetManaCost(eability:GetLevel()-1) and utarget ~= nil then
							utarget = utarget:GetEntityIndex()
							local order = {
								UnitIndex = unit:entindex(),
								AbilityIndex = unit.CastAbilityIndex,
								OrderType = DOTA_UNIT_ORDER_CAST_TARGET,
								TargetIndex = utarget,
								Queue = false
							}
							ExecuteOrderFromTable(order)
						end
					end
					curvar = eability:GetCooldown(eability:GetLevel()) + 1
					
                elseif unit.ThinkerType == "target_point" then
                    --print("casting heal ability " .. EntIndexToHScript(unit.CastAbilityIndex):GetName())
					local utarget
					local eability = EntIndexToHScript(unit.CastAbilityIndex)
					if eability:IsFullyCastable() then
						local tarunits = FindUnitsInRadius(unit:GetTeam(), unit:GetAbsOrigin(), nil, unit:GetAcquisitionRange(), DOTA_UNIT_TARGET_TEAM_ENEMY, DOTA_UNIT_TARGET_ALL, DOTA_UNIT_TARGET_FLAG_NONE, FIND_ANY_ORDER, false)
						--DeepPrintTable(tarCDOTA_PlayerResource:GetUnitlist)
						for kev, funit in pairs(tarunits) do
							if funit:IsAlive() then
								if not utarget then 
									utarget = funit
								elseif funit:GetHealthPercent() < utarget:GetHealthPercent() then
									utarget = funit
								end
							end
						end
						if utarget and utarget:IsAlive() and unit:GetMana() >= eability:GetManaCost(eability:GetLevel()-1) and utarget ~= nil then
							local order = {
								UnitIndex = unit:entindex(),
								AbilityIndex = unit.CastAbilityIndex,
								OrderType = DOTA_UNIT_ORDER_CAST_POSITION,
								Position = utarget:GetOrigin(),
								TargetIndex = utarget:GetEntityIndex(),
								Queue = false
							}
							ExecuteOrderFromTable(order)
						end
					end
					curvar = eability:GetCooldown(eability:GetLevel()) + 1
					
                elseif unit.ThinkerType == "healer" then
                    --print("casting heal ability " .. EntIndexToHScript(unit.CastAbilityIndex):GetName())
					local utarget
					local eability = EntIndexToHScript(unit.CastAbilityIndex)
					if eability:IsFullyCastable() then
						local tarunits = FindUnitsInRadius(unit:GetTeam(), unit:GetAbsOrigin(), nil, unit:GetAcquisitionRange(), DOTA_UNIT_TARGET_TEAM_FRIENDLY, DOTA_UNIT_TARGET_ALL, DOTA_UNIT_TARGET_FLAG_NONE, FIND_ANY_ORDER, false)
						for kev, funit in pairs(tarunits) do
							if funit:IsAlive() then
								if not utarget then 
									utarget = funit
								elseif funit:GetHealthPercent() < utarget:GetHealthPercent() then
									utarget = funit
								end
							end
						end
						if utarget and utarget:IsAlive() and utarget:GetHealthPercent() < 100 then
							utarget = utarget:GetEntityIndex()
							local order = {
								UnitIndex = unit:entindex(),
								AbilityIndex = unit.CastAbilityIndex,
								OrderType = DOTA_UNIT_ORDER_CAST_TARGET,
								TargetIndex = utarget,
								Queue = false
							}
							ExecuteOrderFromTable(order)
						end
					end
					curvar = eability:GetCooldown(eability:GetLevel()) + 1
                end
				
                unit.NextOrderTime = GameRules:GetGameTime() + curvar
            end
        end   

    elseif GameRules:State_Get() >= DOTA_GAMERULES_STATE_POST_GAME then
        return nil
    end
    return 1
end

function GameMode:util_OnTakeDamage( filterTable )
    local damage = filterTable["damage"] --Post reduction
   --local ability = EntIndexToHScript( filterTable["entindex_inflictor_const"] )
    local victim = EntIndexToHScript( filterTable["entindex_victim_const"] )
	local attacker = filterTable["entindex_attacker_const"]
    if attacker then
		attacker = EntIndexToHScript( filterTable["entindex_attacker_const"] )
		if not attacker:IsHero() and not attacker:IsAncient() then
			local uaby = victim:FindAbilityByName("ve_paladins_arena_unit_buff")
			local at_uaby = attacker:FindAbilityByName("ve_paladins_arena_unit_buff")
			if uaby then
				local reduce_damage_pct = 100-uaby:GetSpecialValueFor("damage_reduce") 
				damage = damage * reduce_damage_pct/100
				--GameRules:SendCustomMessage("hp: "..victim:GetHealth().." damage: "..filterTable["damage"].." reduced_damage: "..reduce_damage_pct.." health: "..damage, 0,0)
				filterTable["damage"] = damage
			elseif uaby == nil and at_uaby and victim:IsHero() then
				local taken_damage_pct = 100-at_uaby:GetSpecialValueFor("damage_taken") 
				damage = damage * taken_damage_pct/100
				filterTable["damage"] = damage
				--GameRules:SendCustomMessage("hp: "..victim:GetHealth().." damage: "..filterTable["damage"].." reduced_damage: "..taken_damage_pct.." health: "..damage, 0,0)
			end
		end
	end
    --local damagetype = filterTable["damagetype_const"]



	return true
end



function GameMode:FilterModifyGold( filterTable )
		DeepPrintTable(filterTable)
        if filterTable["reason_const"] == DOTA_ModifyGold_CreepKill then
            filterTable["gold"] = 1.75*filterTable["gold"]
        end
    return true
end

function util_onPlayerReConnect(keys)
	DebugPrint( '[BAREBONES] OnPlayerReconnect' )
	--DeepPrintTable(keys)
	local newState = GameRules:State_Get()
	if newState >= DOTA_GAMERULES_STATE_STRATEGY_TIME then  
		--print(PlayerResource:GetSelectedHeroID(keys.PlayerID))
		if PlayerResource:GetSelectedHeroID(keys.PlayerID) == -1 then
			PlayerResource:GetPlayer(keys.PlayerID):MakeRandomHeroSelection()
		end
	end	
end
    

-- call this via "player_connect_full" event pass event data to this function
function util_OnPlayerLoaded( playerID )
  
    local status, err = pcall(function() 
		local ply = EntIndexToHScript(playerID+1)  
		--Timers:CreateTimer(0.03, function() -- To prevent it from being -1 when the player is created
			--if not ply then 
			--	SetValidStatus(playerID, false)
			--	return
			--end
			if not CDOTA_PlayerResource.PlayerData[playerID] then
				CDOTA_PlayerResource.PlayerData[playerID] = {}
				CDOTA_PlayerResource:SetUnitlist(playerID, thisunitlist)
				CDOTA_PlayerResource:SetUpgradelist(playerID, GameRules.upgradedata)
				CDOTA_PlayerResource:SetIncome(playerID, 1)
				CDOTA_PlayerResource:SetFood(playerID, 9)
				CDOTA_PlayerResource:SetMaxFood(playerID, 25)
				--SetValidStatus(playerID, true)
				--DeepPrintTable(PlayerData[playerID].unitlist)
			end
		--end)

	end)
	if not status then
		CustomGameEventManager:Send_ServerToAllClients( "error_debuger", {g_error = err, status = status} )
		print("\n *=* [VE ERROR] ********** " .. err)	
	end	
	

end


function PrecacheEveryThingFromKV( context )
    local kv_files = {  "scripts/npc/npc_units_custom.txt",
                            "scripts/npc/npc_abilities_custom.txt",
                            "scripts/npc/npc_heroes_custom.txt",
                            "scripts/npc/npc_abilities_override.txt",
                            "npc_items_custom.txt"
                          }
    for _, kv in pairs(kv_files) do
        local kvs = LoadKeyValues(kv)
        if kvs then
            print("BEGIN TO PRECACHE RESOURCE FROM: ", kv)
            PrecacheEverythingFromTable( context, kvs)
        end
    end
end

function PrecacheEverythingFromTable( context, kvtable)
    for key, value in pairs(kvtable) do
        if type(value) == "table" then
            PrecacheEverythingFromTable( context, value )
        else
            if string.find(value, "vpcf") then
                PrecacheResource( "particle",  value, context)
                print("PRECACHE PARTICLE RESOURCE", value)
            end
            if string.find(value, "vmdl") then  
                PrecacheResource( "model",  value, context)
                print("PRECACHE MODEL RESOURCE", value)
            end
            if string.find(value, "vsndevts") then
                PrecacheResource( "soundfile",  value, context)
                print("PRECACHE SOUND RESOURCE", value)
            end
        end
    end
end